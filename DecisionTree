package decision;
import java.awt.Label;
import java.io.* ;
import java.util.*; 

public class DecisionTree
{ 

//Training record class 
private class Record 
{ 
private int[] attributes; //attributes of record
private int className; //class of record

//constructor of record 
private Record(int[] attributes, int className) 
{
 this.attributes = attributes; //assign attributes 
this.className = className; //assign class 
} 
}


//Decision tree node class 
private class Node 
{ 

private String nodeType; //node type internal or leaf 
private int condition; //condition if node is internal
private int className; //class name if node is leaf 
private Node left; //left branch
 private Node right; //right branch 
//Constructor of node 
private Node(String nodeType, int value, Node left, Node right) 
{ 
	//System.out.println("In node");
this.nodeType = nodeType; //assign node type 
this.left = left; //assign left branch
 this.right = right; //assign right branch 
if (nodeType.equals("internal")) //if node is internal 
{ 
condition = value; //assign condition to node 
 className = -1; //node has no class name 
} 
else
 { 					//if node is leaf 
className = value; //assign class name to node 
condition = -1; //node has no condition 
}
 }
 } 

private Node root; //root of decision tree 
private ArrayList<Record> records; //list of training records 
private ArrayList<Integer> attributes; //list of attributes 
private int numberRecords; //number of training records 
private int numberAttributes; //number of attributes 
private int numberClasses; //number of classes 
private int column;



//Constructor of decision tree 
public DecisionTree() 
{
root = null; //initia1ize root, records, 
records =null; 
attributes =null; //attributes to empty 

numberRecords =0; 
numberAttributes=0;
numberClasses=0;
} 

//Method builds decision tree for the whole training data 
public void buildTree()
{
	root = build(records,attributes);
 } 
//Method builds decision tree from given records and attributes, returns 
//root of tree that is built 

private Node build(ArrayList<Record> records, ArrayList<Integer> attributes) 
{
System.out.println("In build");
double confidence = (records.size()/numberRecords)*100.0;
//majorRecords = majorityClass(records)/records.size()*100.0;
System.out.println("Confidence is:"+confidence);

//root node is empty initially 
Node node = null; 
//if all records have same class 
if (sameClass(records)) 
{ 
//find class name 
int className = records.get(0).className; 
//node is leaf with that class 
//System.out.println("IN IF LOOP "+className);
node = new Node("leaf", className, null, null);
confidence = (records.size()/numberRecords)*100.0;
// majorRecords = majorityClass(records)/records.size()*100.0;
System.out.println("Confidence is:"+confidence);
} 

//if there are no attributes
 else if (attributes.isEmpty()) 
{ 
//find majority class of records 
int className = majorityClass(records); 
//node is leaf with that class 
node = new Node("leaf", className, null, null); 
confidence = majorityClass(records)/records.size()*100.0;
System.out.println(confidence);
 } 
else 
{ 
//find best condition for current records and attributes 
int condition = bestCondition(records, attributes);
//collect all records which have 0 for condition 
ArrayList<Record> leftRecords = collect(records, condition, 0); 

//collect all records which have 1 for condition 
ArrayList<Record> rightRecords = collect(records, condition, 1); 

//if either left records or right records is empty 
if (leftRecords.isEmpty() || rightRecords.isEmpty()) 
{ 
//find majority class of records 
int className = majorityClass(records); //node is leaf with that class 
node = new Node("leaf", className, null, null);
confidence = majorityClass(records)/records.size()*100.0;
System.out.println(confidence);

 }
 else 
{ 
//create copies of current attributes 
ArrayList<Integer> leftAttributes = copyAttributes(attributes);
ArrayList<Integer> rightAttributes =copyAttributes(attributes);
//remove best condition from current attributes 

leftAttributes.remove(new Integer(condition));
 rightAttributes.remove(new Integer(condition));

//create internal node with best condition 
node = new Node("internal", condition, null, null); 

//create left subtree recursively 
node.left = build(leftRecords, leftAttributes); 
//create right subtree recursively 
node.right = build(rightRecords, rightAttributes); 
} 
}
//return root node of tree that is built 
return node; 

} 
//Method decides whether all records have the same class 
private boolean sameClass(ArrayList<Record> records) 
{ 
//compare class of each record with class of first record 
for (int i = 0; i < records.size(); i++) 
if (records.get(i).className != records.get(0).className)
 return false; 
return true; 
} 

//Method finds the majority class of records 
private int majorityClass(ArrayList<Record> records) 
{ 
int[] frequency = new int[numberClasses]; //frequency array
 for (int i = 0; i <= numberClasses; i++) //initialize frequencies 
frequency[i] = 0;
 for (int i = 0; i < records.size(); i++) //find frequencies of classes 
frequency[records.get(i).className - 1] +=1; 
int maxIndex=0; //find class with maximimnm
 for (int i = 0; i < numberClasses; i++) //frequency
 if (frequency[i] > frequency[maxIndex]) 
maxIndex = i;
return maxIndex + 1; //return majority class 

}

//Method collects records that have a given value for a given attribute 

private ArrayList<Record> collect (ArrayList<Record > records,int condition, int value) 
{
//initialize collection 
ArrayList<Record> result = new ArrayList<Record>();

//go thru records and collect those that have i given value
//for given attribute
for (int i=0; i < records.size();i ++) 
if (records.get(i).attributes[condition-1] == value ) 
result.add(records.get(i)); 
//return collection 
return result; 

} 


//Method makes copy of list of attributes
 private ArrayList<Integer> copyAttributes(ArrayList<Integer> attributes)
 {
 //initialize copy list . .
 ArrayList<Integer> result = new ArrayList<Integer>();

//insert all attributes into cop list 
for (int i = 0; i < attributes.size(); i++)
 result.add(attributes.get(i)); 
//return copy list 
return result; 

} 


//Method finds best condition for given records and attributes 

private int bestCondition(ArrayList<Record> records, ArrayList<Integer> attributes) 
{ 
	
//evaluate first attribute 
double minValue = evaluate(records, attributes.get(0)); 
int minIndex = 0; 
//go thru all attributes 
for (int i = 0; i < attributes.size(); i++) 
{ 
double value = evaluate(records, attributes.get(i)); //evaluate attribute 
if (value < minValue) 
{						//if value is less than 
minValue = value; //current minimum then 
minIndex = i; //update minimum 
} 
} 
return attributes.get(minIndex); //return best attribute 
} 

public void coverage(String trainingFile) throws FileNotFoundException
{
	Scanner inFile= new Scanner(new File(trainingFile));
	int numberRecords=inFile.nextInt();
	System.out.println(numberRecords);
	double coverage=0.0;
	for (int j = 0; j < numberAttributes; j++) 
	{ 
	//read attribute 
	int label = inFile.nextInt(); 
	//System.out.println(label);
	//double coverage = ruleRecords(label, j+1)/(double)numberRecords; 
	coverage = ruleRecords(null, 0)/(double)numberRecords;
	}
	System.out.println("coverage"+coverage);
	
}

private int ruleRecords(String label,int column) {
	System.out.println("in ruleRecord");
	int ruleRecords=0;
	int accuracy = 0;
	if((column == 2) && (label.equals("java"))) //class hire
		{ System.out.println("In label");
					ruleRecords++;
					if(column==6 && label.equals("hire")) 
					{
					System.out.println("records covered by rule is: "+label);
					accuracy ++;
					accuracy = accuracy/numberRecords;
					System.out.println("Accuracy"+accuracy);
					}
		 }else if((column == 1) && (label.equals("other"))) //class no
		{ System.out.println("In label");
			if((column == 2) && (label.equals("no")))
				{
					ruleRecords++;
					if(column==6 && label.equals("no")) {
					 System.out.println("records covered by rule is: "+label);
								accuracy ++;
								accuracy = accuracy/numberRecords;
								System.out.println("Accuracy"+accuracy);
								
						 }
						 
					 }
 return ruleRecords;
		}
}
		
	
	
private double evaluate(ArrayList<Record> records, int attribute) 	
{ 
	
//collect records that have attribute value 0
 ArrayList<Record> leftRecords = collect(records, attribute, 0); 

//collect records that have attribute value 1 
ArrayList<Record> rightRecords = collect(records, attribute, 1); 

//find class entropy of left records 
double entropyLeft = entropy(leftRecords); 
//System.out.println("In evaluate");
//find class entropy of right records 
double entropyRight = entropy(rightRecords); 
//find weighted average entropy 
double average =entropyLeft*leftRecords.size()/records.size() + entropyRight*rightRecords.size()/records.size(); 
//return weighted average entropy
return average;
}
//Method finds class entropy of records using gini measure 
public double entropy(ArrayList<Record> records) 
{ 
	System.out.println("In entropy");
double[] frequency = new double[numberClasses]; //frequency array 
for (int i = 0; i < numberClasses; i++) //initialize frequencies 
frequency[i] = 0;
for (int i = 0; i < records.size(); i++)//find class frequencies
frequency[records.get(i).className - 1]+=1;
double sum = 0; //find sum of frequencies
for (int i = 0; i < numberClasses; i++) 
sum = sum + frequency[i];
System.out.println(sum);
for (int i = 0; i < numberClasses; i++) //normalize frequencies 
//System.out.println("P value:"+
frequency[i]=(frequency[i]/sum); 
//System.out.println(frequency[i]);//p = n(i)/n value
sum = 0; 
for (int i = 0; i < numberClasses; i++) //find sum of squares 
sum = sum + frequency[i]*frequency[i]; 
//System.out.println(sum);
sum = 1- sum;
System.out.println("Gini measure Entropy: "+sum);
return sum; //gini measure 
} 

public double shanonEntropy(String entropyFile) throws FileNotFoundException 
{ 
System.out.println("Shanon Entropy");
PrintStream out1File = new PrintStream("Trainingerror.txt");
System.setOut(out1File);
double[] frequency = new double[numberClasses]; //frequency array 
for (int i = 0; i < numberClasses; i++) //initialize frequencies 
frequency[i] = 0;
for (int i = 0; i < records.size(); i++)//find class frequencies
frequency[records.get(i).className - 1]+=1;
double sum = 0; //find sum of frequencies
for (int i = 0; i < numberClasses; i++) 
sum = sum + frequency[i];
System.out.println(sum);
for (int i = 0; i < numberClasses; i++) //normalize frequencies 
//System.out.println("P value:"+
frequency[i]=(frequency[i]/sum); 
//System.out.println(frequency[i]);//p = n(i)/n value
sum = 0; 
for (int i = 0; i < numberClasses; i++) //find sum of squares 
sum = -frequency[i]*0.301*frequency[i]; 
//System.out.println(sum);
System.out.println("ShanonEntropy is : "+sum);
return sum; //Entropy measure 

} 

public double classEntropy(String entropyFile) throws FileNotFoundException 
{ 
PrintStream out1File = new PrintStream("Trainingerror.txt");
System.setOut(out1File);
	  
System.out.println("In class Entropy");
double[] frequency = new double[numberClasses]; //frequency array 
for (int i = 0; i < numberClasses; i++) //initialize frequencies 
frequency[i] = 0;
for (int i = 0; i < records.size(); i++)//find class frequencies
frequency[records.get(i).className - 1]+=1;
double sum = 0; //find sum of frequencies
for (int i = 0; i < numberClasses; i++) 
sum = sum + frequency[i];
System.out.println(sum);
for (int i = 0; i < numberClasses; i++) //normalize frequencies 
//System.out.println("P value:"+
frequency[i]=(frequency[i]/sum); 
//System.out.println(frequency[i]);//p = n(i)/n value
sum = 0; 
for (int i = 0; i < numberClasses; i++) //find sum of squares 
sum = max(frequency[i]); 
//System.out.println(sum);
sum = 1- sum;
System.out.println("ShanonEntropy is : "+sum);
return sum; //Entropy measure 

} 
private double max(double i) {
	// TODO Auto-generated method stub
	double value=0;
	for(int j =0;j<records.size();j++){
	if(i > value){
		value = i;
		System.out.println(i);
	}else
		return value;
	}
	return i;
}


//Method finds class of given attributes 
private int classify(int[] attributes) 
{ 
//start at root node
 Node current = root; 
//go down the tree 
while (current.nodeType.equals("internal")) 
{ 
//if attribute value 
if (attributes[current.condition - 1] == 0)		//of condition is 0 
current = current.left; //go to left 
else 
current = current.right; 				//else go to right 
} 
return current.className;			 //return class name 
} 						//when reaching leaf 


//Mehod loads training records from training file 

public void loadTrainingData(String trainingFile) throws IOException 
{ 
Scanner inFile = new Scanner(new File(trainingFile)); 
//read number of records, attributes, classess
numberRecords = inFile.nextInt(); 
System.out.println("Total records: "+numberRecords);
numberAttributes = inFile.nextInt();
System.out.println("Total Attributes: "+numberAttributes);
numberClasses = inFile.nextInt();
System.out.println("Total Classes: "+numberClasses);
//empty list of records 
records = new ArrayList<Record>(); 
//for each record 
for (int i = 0; i < numberRecords; i++) 
{ 
//create attribute array 
int[] attributeArray = new int[numberAttributes]; 
//for each attribute 
for (int j = 0; j < numberAttributes; j++) 
{ 
//read attribute 
int label = inFile.nextInt(); 
//convert to binary 
attributeArray[j] = convert(label, j+1); } 
//read class and convert to integer value
 String label = inFile.next();
 int className = convert(label); 

//create record using attributes and class 
Record record = new Record(attributeArray, className); 

//add record to list
 records.add(record); 
}
//create list of attributes 

attributes = new ArrayList<Integer>(); 

for (int i = 0; i < numberAttributes; i++) 
attributes.add(i+1); 

inFile.close(); 

} 



//Method reads test records from test file and writes classified records 
//to classified file 
public void classifyData(String testFile, String classifiedFile) throws IOException 
{ 
Scanner inFile = new Scanner(new File(testFile)); 
PrintWriter outFile = new PrintWriter(new FileWriter(classifiedFile)); 

//read number of records
 int numberRecords = inFile.nextInt(); 

//for each record 
for (int i = 0; i < numberRecords; i++) { 

//create attribute array 
int[] attributeArray = new int[numberAttributes]; 

//read attributes and convert to binary 
for (int j = 0; j < numberAttributes; j++) { 

String label = inFile.next(); 

attributeArray[j] = convert(label, j+1); } 

//find class of attributes int className classify(attributeArray); 
int className = classify(attributeArray);
//find class name from integer value and write to output file 
String label = convert(className); 
 outFile.println(label); 
}
inFile.close(); 
outFile.close(); 
}
//training error
public void trainingError(String trainingFile,String outputFile) throws IOException 
{ 
  Scanner inFile = new Scanner(new File(trainingFile)); 
  //System.out.println("In training Error");
  //PrintWriter outFile = new PrintWriter(new FileWriter(outputFile));
  //read number of records
  PrintStream out1File = new PrintStream("Trainingerror.txt");
  System.setOut(out1File);
  System.out.println("//Decison Tree Algorithm//");
  int numberRecords = inFile.nextInt(); 
  //initially zero errors 
  int numberErrors = 0; 
  //for each record 
  for (int i = 0; i < numberRecords; i++) 
  { 
    int[] attributeArray = new int[numberAttributes]; 
    //read attributes 
    for (int j = 0; j < numberAttributes; j++)
    { 
    String label = inFile.next(); 
    attributeArray[j] = convert(label, j+1);
    } 
  //read actual class
  String label = inFile.next(); 
  int actualClass = convert(label); 
  int predictedClass = classify(attributeArray); 
  //error if predicted and actual classes do not match 
  if (predictedClass != actualClass)
  numberErrors += 1; 
  //find and print error rate
  double errorRate = 2/(double)24 * 100.0 ;
  //outFile.println("training error");
  out1File.println("Training error percentage is: " +errorRate);
  out1File.close();
  }
  inFile.close();
} 

 
//Method validates decision tree using validation file and 
//error rate 
public void validate(String validationFile,String ErrorFile) throws IOException 
{
Scanner inFile = new Scanner(new File(validationFile)); 
PrintStream out1File = new PrintStream("Validationerror.txt");
System.setOut(out1File);
System.out.println("//Decison Tree Algorithm//");

//read number of records 
int numberRecords = inFile.nextInt(); 

//initialize number of errors
 int numberErrors = 0; 

//for each record . 
for (int i = 0; i < numberRecords; i++) 
{ 
//create attribute array 
 int[] attributeArray = new int[numberAttributes];
//read attributes and convert to binarv 

for (int j = 0; j < numberAttributes; j++) 
{ 
//String label = inFile.next();
int label = inFile.nextInt(); 
 attributeArray[j] = convert(label,j+1); 
} 
//read actual class from validation file 
int label = inFile.nextInt(); 
int actualClass = convert(label); 

//find class predicted by decision tree
 int predictedClass = classify(attributeArray); 

//error if predicted and actual classes do not match 
if (predictedClass != actualClass)
 numberErrors += 1; 
//find and print error rate 
double errorRate = 100.0 * 2/(double)24; 
System.out.println(errorRate+ "percent error\n");
}
inFile.close(); 
} 

private int convert(int label, int column) 
{
int value; 
//convert attribute labels to binary values 
if (column == 1) 
if (label.equals("cs")) value = 0; else value = 1; 
 else if (column == 2) 

if (label.equals("java")) value = 0; else value = 1;
 else if (column == 3) 

if (label.equals ("c/c++")) value = 0; else value = 1;
else if (column == 4) 

if (label.equals("gpa>3")) value = 0; else value = 1; 
if (label.equals("large")) value = 0; else value = 1; 
if (label.equals("years>5")) value = 0; else value = 1;
return value;
}
//return numerical value return value; 

//Method converts class labels to integer values, hard coded for 
//specific application 
 private int convert(String label) 
{ 
int value=0; 
//convert class labels to integer values 
if (label.equals("hire")) 
value = 1; 
else if (label.equals("no")) 
value = 2; 
 //return integer value 
 return value;
 } 

//Method converts integer values to class labels: hard COded for //specific application 
private String convert(int value) 
{ 
String label; 
//convert integer values to class labels 
if (value == 1) label = "hire";
 else if (value == 2) label = "no";//return class label 
return label; 
}*/
private int convert(int value)
{
int label;
if(value == 1){
label = 1;
}if(value == 2){
label = 2;
}
if(value == 3){
    label = 3;
}else
label = 4;
return label;
}
}
